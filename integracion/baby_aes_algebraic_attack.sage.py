

# This file was *autogenerated* from the file baby_aes_algebraic_attack.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_2 = Integer(2); _sage_const_0x063b = Integer(0x063b); _sage_const_0x21c2 = Integer(0x21c2); _sage_const_16 = Integer(16); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_5 = Integer(5); _sage_const_6 = Integer(6); _sage_const_7 = Integer(7); _sage_const_8 = Integer(8); _sage_const_9 = Integer(9); _sage_const_10 = Integer(10); _sage_const_11 = Integer(11); _sage_const_12 = Integer(12); _sage_const_13 = Integer(13); _sage_const_14 = Integer(14); _sage_const_15 = Integer(15)
from babyAES_block_cipher import BabyAESCipher
from claasp.cipher_modules.models.sat.sat_models.sat_cipher_model import SatCipherModel
from claasp.utils.integer import to_binary
import json


babyAES = BabyAESCipher(number_of_rounds = _sage_const_3 , word_size = _sage_const_4 , state_size = _sage_const_2 )
sat = SatCipherModel(babyAES)

# Generacion de valores
plaintext = _sage_const_0x063b 
key = _sage_const_0x21c2 

plaintext_binary = to_binary(plaintext, _sage_const_16 )
#print(to_binary(plaintext, 16)[::-1])
#print(to_binary(key, 16)[::-1])

ciphertext = babyAES.evaluate([key, plaintext])
ciphertext_binary = to_binary(ciphertext, _sage_const_16 )
#print(ciphertext_binary)
fixed_variables = [{
    'component_id': 'plaintext',
    'constraint_type': 'equal',
    'bit_positions': [_sage_const_0 , _sage_const_1 , _sage_const_2 , _sage_const_3 , _sage_const_4 , _sage_const_5 , _sage_const_6 , _sage_const_7 ],
    'bit_values': [plaintext_binary[i] for i in range(_sage_const_8 )]
}, {
    'component_id': 'plaintext',
    'constraint_type': 'equal',
    'bit_positions': [_sage_const_8 , _sage_const_9 , _sage_const_10 , _sage_const_11 , _sage_const_12 , _sage_const_13 , _sage_const_14 , _sage_const_15 ],
    'bit_values': [plaintext_binary[i] for i in range(_sage_const_8 , _sage_const_16 )]
}, {
    'component_id': 'cipher_output_2_14',
    'constraint_type': 'equal',
    'bit_positions': [_sage_const_0 , _sage_const_1 , _sage_const_2 , _sage_const_3 , _sage_const_4 , _sage_const_5 , _sage_const_6 , _sage_const_7 ],
    'bit_values': [ciphertext_binary[i] for i in range(_sage_const_8 )]
}, {
    'component_id': 'cipher_output_2_14',
    'constraint_type': 'equal',
    'bit_positions': [_sage_const_8 , _sage_const_9 , _sage_const_10 , _sage_const_11 , _sage_const_12 , _sage_const_13 , _sage_const_14 , _sage_const_15 ],
    'bit_values': [ciphertext_binary[i] for i in range(_sage_const_8 ,_sage_const_16 )]
}]
sat.build_cipher_model(fixed_variables)
solution = sat.solve('cipher', solver_name="cryptominisat")


#res = {"solver": "cryptominisat", "plaintext": f'0x{plaintext:04x}', "ciphertext": f'0x{ciphertext:04x}', "key": solution['components_values']['key']['value'], "time": solution['solving_time_seconds']}
#print(json.dumps(res))

print(solution)

